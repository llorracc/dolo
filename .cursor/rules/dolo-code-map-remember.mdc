---
description: File map of the dolo repository to help understand the codebase structure
globs: 
---

# Dolo Repository Structure
<file_map>
├── dolo
│   ├── .cursor
│   │   └── rules
│   │       └── dolo-docs.mdc
│   ├── AI-prompts_MDP
│   │   └── dolo_add-docs-to-py-files.md
│   ├── bin
│   │   ├── dolo
│   │   └── dolo-lint
│   ├── docs
│   │   ├── finite_iteration.md
│   │   ├── index.md
│   │   ├── inspect.md
│   │   ├── installation.md
│   │   ├── model_api.md
│   │   ├── model_specification.md
│   │   ├── modeling_language.md
│   │   ├── parameterized_expectations.md
│   │   ├── perfect_foresight.md
│   │   ├── perturbation.md
│   │   ├── processes.md
│   │   ├── simulation.md
│   │   ├── steady_state.md
│   │   ├── time_iteration.md
│   │   └── value_iteration.md
│   ├── dolo
│   │   ├── algos
│   │   │   ├── __init__.py
│   │   │   ├── bruteforce_lib.py
│   │   │   ├── commands.py
│   │   │   ├── egm.py
│   │   │   ├── ergodic.py
│   │   │   ├── fb.py
│   │   │   ├── improved_time_iteration.py
│   │   │   ├── invert.py
│   │   │   ├── perfect_foresight.py
│   │   │   ├── perturbation.py
│   │   │   ├── perturbations_higher_order.py
│   │   │   ├── results.py
│   │   │   ├── simulations.py
│   │   │   ├── steady_state.py
│   │   │   ├── time_iteration.py
│   │   │   └── value_iteration.py
│   │   ├── compiler
│   │   │   ├── __init__.py
│   │   │   ├── derivatives.py
│   │   │   ├── eval_formula.py
│   │   │   ├── factories.py
│   │   │   ├── misc.py
│   │   │   ├── model_import.py
│   │   │   ├── model.py
│   │   │   ├── objects.py
│   │   │   ├── recipes.py
│   │   │   └── recipes.yaml
│   │   ├── misc
│   │   │   ├── __init__.py
│   │   │   ├── caching.py
│   │   │   ├── decorators.py
│   │   │   ├── display.py
│   │   │   ├── dprint.py
│   │   │   ├── graphs.py
│   │   │   ├── groot.py
│   │   │   ├── itprinter.py
│   │   │   ├── multimethod.py
│   │   │   ├── termcolor.py
│   │   │   └── timing.py
│   │   ├── numeric
│   │   │   ├── discretization
│   │   │   │   ├── __init__.py
│   │   │   │   ├── discretization.py
│   │   │   │   └── quadrature.py
│   │   │   ├── extern
│   │   │   │   ├── __init__.py
│   │   │   │   ├── lmmcp.py
│   │   │   │   └── qz.py
│   │   │   ├── optimize
│   │   │   │   ├── __init__.py
│   │   │   │   ├── ncpsolve.py
│   │   │   │   └── newton.py
│   │   │   ├── __init__.py
│   │   │   ├── decision_rule.py
│   │   │   ├── distribution.py
│   │   │   ├── filters.py
│   │   │   ├── grids.py
│   │   │   ├── matrix_equations.py
│   │   │   ├── misc.py
│   │   │   ├── processes.py
│   │   │   ├── serial_operations.py
│   │   │   ├── taylor_expansion.py
│   │   │   └── tensor.py
│   │   ├── tests
│   │   │   ├── __init__.py
│   │   │   ├── test_caching.py
│   │   │   ├── test_complementarity_problems.py
│   │   │   ├── test_customdr.py
│   │   │   ├── test_egm.py
│   │   │   ├── test_ergodic.py
│   │   │   ├── test_formula_evaluation.py
│   │   │   ├── test_grid.py
│   │   │   ├── test_grids.py
│   │   │   ├── test_iid_processes.py
│   │   │   ├── test_import.py
│   │   │   ├── test_irf.py
│   │   │   ├── test_linter.py
│   │   │   ├── test_model_import.py
│   │   │   └── test_serial_ncpsolve.py
│   │   ├── __init__.py
│   │   ├── config.py
│   │   └── linter.py
│   ├── examples
│   │   ├── dynare_modfiles
│   │   │   ├── example1_use_dll.mod
│   │   │   ├── example1_varexo_det.mod
│   │   │   ├── example1.mod
│   │   │   ├── example2.mod
│   │   │   ├── osr_example.mod
│   │   │   ├── predetermined_variables.mod
│   │   │   ├── ramsey.mod
│   │   │   ├── ramst_a.mod
│   │   │   ├── ramst_initval_file.mod
│   │   │   ├── ramst_normcdf.mod
│   │   │   ├── ramst.mod
│   │   │   ├── ramst2.mod
│   │   │   ├── t_lag2_check.mod
│   │   │   ├── t_lag2_checka.mod
│   │   │   ├── t_lag2.mod
│   │   │   ├── t_lag2a.mod
│   │   │   ├── t_lag2b.mod
│   │   │   ├── t_periods_a.mod
│   │   │   ├── t_periods.mod
│   │   │   ├── t_sgu_ex1.mod
│   │   │   ├── test_matlab.mod
│   │   │   └── variance_0.mod
│   │   ├── models
│   │   │   ├── consumption_savings_iid_egm.yaml
│   │   │   ├── consumption_savings_iid.yaml
│   │   │   ├── consumption_savings.yaml
│   │   │   ├── rbc_ar1.yaml
│   │   │   ├── rbc_iid.yaml
│   │   │   ├── rbc_mc.yaml
│   │   │   ├── rbc.yaml
│   │   │   └── rmt3_ch11.yaml
│   │   ├── models_
│   │   │   ├── capital.yaml
│   │   │   ├── consumption_savings.yaml
│   │   │   ├── Figv4_1191.yaml
│   │   │   ├── NK_dsge.yaml
│   │   │   ├── open_economy_1d.yaml
│   │   │   ├── open_economy.yaml
│   │   │   ├── rbc_ar1.yaml
│   │   │   ├── rbc_condition.yaml
│   │   │   ├── rbc_iid_ar1.yaml
│   │   │   ├── rbc_iid.yaml
│   │   │   ├── rbc_mc.yaml
│   │   │   ├── rbc_mixture.yaml
│   │   │   ├── rbc_product_newstyle.yaml
│   │   │   ├── rbc_product.yaml
│   │   │   ├── rbc_taxes.yaml
│   │   │   ├── rbc.yaml
│   │   │   ├── rbc2.yaml
│   │   │   └── sudden_stop.yaml
│   │   ├── models_with_errors
│   │   │   └── rbc_fuzzy.yaml
│   │   └── notebooks
│   │       ├── consumption_savings_iid_egm.ipynb
│   │       ├── consumption_savings_iid.ipynb
│   │       ├── consumption_savings.ipynb
│   │       ├── rbc_model.ipynb
│   │       ├── rbc_perfect_foresight.ipynb
│   │       ├── rmt3_ch11.ipynb
│   │       └── sudden_stop.ipynb
│   ├── experiments
│   │   └── python_self_contained.py
│   ├── .gitpod.yml
│   ├── LICENSE
│   ├── llorracc-dolo.code-workspace
│   ├── mkdocs.yml
│   ├── pyproject.toml
│   ├── README.md
│   ├── sync-dolo-repos.sh
│   ├── TODO
│   └── Untitled.ipynb



<Complete Definitions>
Path: /Volumes/Sync/GitHub/llorracc/dolo/dolo/algos/__init__.py

---
Classes:
  Class: __init__
    Properties:
      - __author__ = "pablo"
---


Path: /Volumes/Sync/GitHub/llorracc/dolo/dolo/algos/bruteforce_lib.py

---
Classes:
  Class: bruteforce_lib
    Methods:
      - def prod(l):
      - def B_prod(bases):
      - def mult_AB(dres, jres):
  Class: SparseTensor
    Methods:
      - def __init__(self, indices, values, shape):
      - def lin_indices(self):
      - def reshape(self, shape):
      - def as_spmatrix(self, dims=None):
      - def as_array(self, dims=None):
      - def dres_to_sparse(dres):
      - def serial_solve(A, B, diagnose=True):
      - def jres_to_sparse(jres):
      - def compact_ddx(res, fut_S):
      - def construct_j2(jres):
  Class: SmartJacobian
    Methods:
      - def __init__(self, res, dres, jres, fut_S, grid):
      - def B(self):
      - def get_filter(self):
      - def jac_1(self):
      - def j2_A(self):
      - def j2_B(self):
      - def jac_2(self):
      - def jac(self):
      - def solve(self, rr):
      - def solve_sp(self, rr):
      - def solve_smart(
        self, rr, tol=1e-10, maxit=1000, verbose=False, filt=None, scale=1.0
    ):
      - def solve_ind(self, rr, tol=1e-12):
      - def classical_perturbation(g_s, g_x, f_s, f_x, f_S, f_X):
      - def simple_max(T):
      - def newtonator(g_s, g_x, f_s, f_x, f_S, f_X):
      - def spectral_radius(g_s, g_x, f_s, f_x, f_S, f_X, X=None):
---


Path: /Volumes/Sync/GitHub/llorracc/dolo/dolo/algos/commands.py

---
Classes:
  Class: commands
    Properties:
      - approximate_controls = perturb
---


Path: /Volumes/Sync/GitHub/llorracc/dolo/dolo/algos/egm.py

---
Classes:
  Class: egm
    Methods:
      - def egm(
    model: Model,
    dr0: DecisionRule = None,
    verbose: bool = False,
    details: bool = True,
    a_grid=None,
    η_tol=1e-6,
    maxit=1000,
    grid=None,
    dp=None,
):
      - def vprint(t):
      - def drfut(i, ss):
---


Path: /Volumes/Sync/GitHub/llorracc/dolo/dolo/algos/ergodic.py

---
Classes:
  Class: ergodic
    Methods:
      - def trembling_hand(A: "N*n1*...*nd", x: "N*d", w: "float"):
      - def ergodic_distribution(model: Model, dr: DecisionRule):
      - def ergodic_distribution(
    model: Model,
    dr: DecisionRule,
    exo_grid: UnstructuredGrid,
    endo_grid: UniformCartesianGrid,
    dp: MarkovChain,
    compute_μ=True,
):
      - def ergodic_distribution(
    model: Model,
    dr: DecisionRule,
    exo_grid: EmptyGrid,
    endo_grid: CartesianGrid,
    dp: DiscretizedIIDProcess,
    compute_μ=True,
):
---


Path: /Volumes/Sync/GitHub/llorracc/dolo/dolo/algos/fb.py

---
Classes:
  Class: fb
    Properties:
      - ttol = 1e-10
    Methods:
      - def PhiFB(a, b):
      - def smooth_FB(f, x, a, b):
      - def PhiFB_(a, b):
      - def smooth_FB_(f, x, a, b, df):
      - def smooth(f, x, a, b, df):
      - def smooth_(f, x, a, b):
---


Path: /Volumes/Sync/GitHub/llorracc/dolo/dolo/algos/improved_time_iteration.py

---
Classes:
  Class: improved_time_iteration
    Methods:
      - def prod(l):
      - def inplace(Phi, J):
      - def smooth(res, dres, jres, dx, pos=1.0):
      - def smooth_nodiff(res, dx):
      - def ssmul(A, B):
      - def ssmul_inplace(A, B, O):
      - def d_filt_dx(π, M_ij, S_ij, n_m, N, n_x, dumdr):
  Class: Operator
    Methods:
      - def __init__(self, M_ij, S_ij, dumdr):
      - def shape(self):
      - def _matvec(self, x):
      - def apply(self, π, inplace=False):
      - def as_matrix(self):
      - def invert_jac(res, dres, jres, fut_S, dumdr, tol=1e-10, maxit=1000, verbose=False):
      - def radius_jac(res, dres, jres, fut_S, dumdr, tol=1e-10, maxit=1000, verbose=False):
      - def improved_time_iteration(
    model: Model,
    *,
    dr0: DecisionRule = None,
    verbose: bool = True,
    details: bool = True,
    ignore_constraints=False,
    method="jac",
    dprocess=None,
    interp_method="cubic",
    mu=2,
    maxbsteps=10,
    tol=1e-8,
    smaxit=500,
    maxit=1000,
    compute_radius=False,
    invmethod="iti",
    complementarities=None
) -> ImprovedTimeIterationResult:
      - def vprint(*args, **kwargs):
      - def euler_residuals(  # Compute Euler equation residuals
    f,  # Arbitrage function
    g,  # Transition function
    s,  # State variables
    x,  # Control variables
    dr,  # Decision rule
    dp,  # Discretized process
    p_,  # Parameters
    diff=True,  # Whether to compute derivatives
    with_jres=False,  # Whether to compute Jacobian
    set_dr=True,  # Whether to update decision rule with current controls
    jres=None,  # Pre-allocated Jacobian
    S_ij=None,  # Pre-allocated future states
):
  Class: EvaluationResult
    Methods:
      - def __init__(self, solution, iterations, tol, error):
---


Path: /Volumes/Sync/GitHub/llorracc/dolo/dolo/algos/invert.py

---
Classes:
  Class: invert
    Properties:
      - target = "parallel"
    Methods:
      - def swaplines_tensor(i, j, M):
      - def swaplines_matrix(i, j, M):
      - def swaplines_vector(i, j, M):
      - def swaplines(i, j, M):
      - def substract_tensor(i, j, c, M):
      - def substract_matrix(i, j, c, M):
      - def substract_vector(i, j, c, M):
      - def substract(i, j, c, M):
      - def divide_tensor(i, c, M):
      - def divide_matrix(i, c, M):
      - def divide_vector(i, c, M):
      - def divide(i, c, M):
      - def invert(A, B):
      - def invert_gu(A, Ainv):
      - def solve_gu(A, V):
      - def solve_tensor(A, V, dum):
      - def solve_tensor_old(A, V, dum):
      - def test_list_of_matrices():
      - def serial_solve(A, B, diagnose=True):
      - def mult_AB(dres, jres):
      - def test_list_of_arrays():
---


Path: /Volumes/Sync/GitHub/llorracc/dolo/dolo/algos/perfect_foresight.py

---
Classes:
  Class: perfect_foresight
    Methods:
      - def _shocks_to_epsilons(model, shocks, T):
      - def deterministic_solve(
    model: Model,
    *,  #
    verbose: bool = True,  #
    ignore_constraints: bool = False,  #
    exogenous=None,
    s0=None,
    m0=None,
    T=100,
    maxit=100,
    initial_guess=None,
    solver="ncpsolve",
    keep_steady_state=False,
    s1=None,  # deprecated
    shocks=None,  # deprecated
    tol=1e-6,
):
      - def ff(vec):
      - def ff(vec):
      - def det_residual(model, guess, start, final, shocks, diff=True, jactype="sparse"):
---


Path: /Volumes/Sync/GitHub/llorracc/dolo/dolo/algos/perturbation.py

---
Classes:
  Class: perturbation
    Methods:
      - def get_derivatives(model: Model, steady_state=None):
  Class: BivariateTaylor
    Methods:
      - def __init__(self, m_bar, s_bar, x_bar, C_m, C_s):
      - def eval_s(self, s):
      - def eval_ms(self, m, s):
      - def approximate_1st_order(g_s, g_x, g_e, f_s, f_x, f_S, f_X):
      - def perturb(
    model: Model,
    *,
    details: bool = True,  #
    verbose: bool = True,  #
    steady_state=None,
    eigmax=1.0 - 1e-6,
    solve_steady_state=False,
    order=1,
) -> PerturbationResult:
---


Path: /Volumes/Sync/GitHub/llorracc/dolo/dolo/algos/perturbations_higher_order.py

---
Classes:
  Class: perturbations_higher_order
    Methods:
      - def perturb(
    model: Model,
    *,
    verbose=True,
    details=True,
    order=1,
    return_dr=True,
    steady_state=None,
):
  Class: PerturbationProblem
    Properties:
      - approximate_controls = perturb
    Methods:
      - def __init__(self, f: List[ndarray], g: List[ndarray], sigma: ndarray):
      - def order(self):
      - def state_perturb(problem: PerturbationProblem, verbose=True):
      - def E(vec):
---


Path: /Volumes/Sync/GitHub/llorracc/dolo/dolo/algos/results.py

---
Classes:
  Class: AlgoResult
  Class: TimeIterationResult
    Properties:
      - dr:
      - iterations:
      - complementarities:
      - dprocess:
      - x_converged:
      - x_tol:
      - err:
      - log:
      - trace:
  Class: EGMResult
    Properties:
      - dr:
      - iterations:
      - dprocess:
      - a_converged:
      - a_tol:
      - err:
  Class: ValueIterationResult
    Properties:
      - dr:
      - drv:
      - iterations:
      - dprocess:
      - x_converged:
      - x_tol:
      - x_err:
      - v_converged:
      - v_tol:
      - v_err:
      - log:
      - trace:
  Class: ImprovedTimeIterationResult
    Properties:
      - dr:
      - N:
      - f_x:
      - d_x:
      - x_converged:
      - complementarities:
      - radius:
      - trace_data:
      - L:
  Class: PerturbationResult
    Properties:
      - dr:
      - generalized_eigenvalues:
      - stable:
      - determined:
      - unique:
---


Path: /Volumes/Sync/GitHub/llorracc/dolo/dolo/algos/simulations.py

---
Classes:
  Class: simulations
    Methods:
      - def response(model, dr, varname, T=40, impulse: float = None):
      - def find_index(sim, values):
      - def simulate(
    model: Model,
    dr: DecisionRule,
    *,
    process=None,
    N=1,
    T=40,
    s0=None,
    i0=None,
    m0=None,
    driving_process=None,
    seed=42,
    stochastic=True,
):
      - def tabulate(
    model, dr, state, bounds=None, n_steps=100, s0=None, i0=None, m0=None, **kwargs
):
      - def tabulate_2d(model, dr, states=None, i0=0, s0=None, n=[12, 13]):
      - def plot3d(tab, varname):
      - def plot_decision_rule(plot_controls=None, **kwargs):
---


Path: /Volumes/Sync/GitHub/llorracc/dolo/dolo/algos/steady_state.py

---
Classes:
  Class: steady_state
    Methods:
      - def residuals(model: Model, calib=None) -> Dict[str, List[float]]:
      - def find_steady_state(model: Model, *, m=None):
      - def fobj(v):
      - def find_deterministic_equilibrium(model, verbose=True):
---


Path: /Volumes/Sync/GitHub/llorracc/dolo/dolo/algos/time_iteration.py

---
Classes:
  Class: time_iteration
    Methods:
      - def residuals_simple(f, g, s, x, dr, dprocess, parms):
      - def time_iteration(
    model: Model,  # Model to solve
    *,  #
    dr0: DecisionRule = None,  # Initial guess for decision rule
    verbose: bool = True,  # Whether to print progress
    details: bool = True,  # Whether to return detailed results
    ignore_constraints: bool = False,  # Whether to ignore bounds
    trace: bool = False,  # Whether to store iteration history
    dprocess=None,  # Optional custom discretization
    maxit=1000,  # Maximum iterations
    inner_maxit=10,  # Maximum iterations for inner solver
    tol=1e-6,  # Convergence tolerance
    hook=None,  # Optional callback function
    interp_method="cubic",  # Interpolation method
    # obsolete
    with_complementarities=None,  # Deprecated option
) -> TimeIterationResult:
      - def vprint(t):
---


Path: /Volumes/Sync/GitHub/llorracc/dolo/dolo/algos/value_iteration.py

---
Classes:
  Class: value_iteration
    Methods:
      - def constant_policy(model: Model) -> ConstantDecisionRule:
      - def value_iteration(
    model: Model,
    *,
    verbose: bool = False,  #
    details: bool = True,  #
    tol: float = 1e-6,     # Convergence tolerance
    maxit: int = 500,      # Maximum iterations
    maxit_howard: int = 20 # Maximum Howard improvement steps
) -> ValueIterationResult:
      - def valfun(xx):
      - def choice_value(
    transition, 
    felicity, 
    i_ms: int, 
    s: np.ndarray, 
    x: np.ndarray, 
    drv: DecisionRule,
    dprocess: DiscretizedIIDProcess,
    parms: dict,
    beta: float
) -> float:
  Class: EvaluationResult
    Methods:
      - def __init__(self, solution, iterations, tol, error):
      - def evaluate_policy(  # Evaluate value function for given policy
    model,  # Model to evaluate
    mdr,  # Decision rule to evaluate
    tol=1e-8,  # Convergence tolerance
    maxit=2000,  # Maximum iterations
    grid={},  # Optional custom grid
    verbose=True,  # Whether to print progress
    dr0=None,  # Initial value function guess
    hook=None,  # Optional callback
    integration_orders=None,  # Integration accuracy
    details=False,  # Whether to return details
    interp_method="cubic",  # Interpolation method
):
      - def update_value(
    val: callable,
    g: callable,
    s: np.ndarray,
    x: np.ndarray,
    v: np.ndarray,
    dr: DecisionRule,
    drv: DecisionRule,
    dprocess: DiscretizedIIDProcess,
    parms: dict
) -> np.ndarray:
---


Path: /Volumes/Sync/GitHub/llorracc/dolo/dolo/compiler/__init__.py

---

---


Path: /Volumes/Sync/GitHub/llorracc/dolo/dolo/compiler/derivatives.py

---
Classes:
  Class: derivatives
    Methods:
      - def timeshift(expr, variables, date):
      - def parse_equation(eq_string, vars, substract_lhs=True, to_sympy=False):
      - def model_to_fg(model, order=2):
      - def get_model_derivatives(model, order, calibration=None):
---


Path: /Volumes/Sync/GitHub/llorracc/dolo/dolo/compiler/eval_formula.py

---
Classes:
  Class: eval_formula
    Methods:
      - def eval_formula(expr: str, dataframe=None, context=None):
---


Path: /Volumes/Sync/GitHub/llorracc/dolo/dolo/compiler/factories.py

---
Classes:
  Class: factories
    Methods:
      - def get_name(e):
      - def reorder_preamble(pr):
      - def shift_spec(specs, tshift):
      - def get_factory(model, eq_type: str, tshift: int = 0):
---


Path: /Volumes/Sync/GitHub/llorracc/dolo/dolo/compiler/misc.py

---
Classes:
  Class: misc
    Properties:
      - equivalent_symbols = dict(actions="controls")
    Methods:
      - def calibration_to_vector(symbols, calibration_dict):
      - def calibration_to_dict(symbols, calib):
  Class: LoosyDict
    Methods:
      - def __init__(self, **kwargs):
      - def __getitem__(self, p):
  Class: CalibrationDict
    Methods:
      - def __init__(self, symbols, calib, equivalences=equivalent_symbols):
      - def __getitem__(self, p):
      - def allocating_function(inplace_function, size_output):
      - def new_function(*args, **kwargs):
      - def numdiff(fun, args):
---


Path: /Volumes/Sync/GitHub/llorracc/dolo/dolo/compiler/model_import.py

---
Classes:
  Class: model_import
    Methods:
      - def yaml_import(fname, check=True, check_only=False):
---


Path: /Volumes/Sync/GitHub/llorracc/dolo/dolo/compiler/model.py

---
Classes:
  Class: SymbolicModel
    Properties:
      - regex = re.compile("(.*)<=(.*)<=(.*)")
    Methods:
      - def __init__(self, data):
      - def symbols(self):
      - def variables(self):
      - def equations(self):
      - def definitions(self):
      - def name(self):
      - def filename(self):
      - def infos(self):
      - def options(self):
      - def get_calibration(self):
      - def get_domain(self):
      - def get_exogenous(self):
      - def endo_grid(self):
      - def get_type(d):
      - def get_address(data, address, default=None):
      - def decode_complementarity(comp, control):
  Class: Model
    Methods:
      - def __init__(self, data, check=True, compat=True):
      - def set_changed(self, all=False):
      - def set_calibration(self, *pargs, **kwargs):
      - def calibration(self):
      - def exogenous(self):
      - def domain(self):
      - def discretize(self, grid_options=None, dprocess_options={}):
      - def __compile_functions__(self):
      - def functions(self):
      - def __str__(self):
      - def __repr__(self):
      - def _repr_html_(self):
      - def x_bounds(self):
      - def residuals(self, calib=None):
      - def eval_formula(self, expr, dataframe=None, calib=None):
---


Path: /Volumes/Sync/GitHub/llorracc/dolo/dolo/compiler/objects.py

---
Classes:
  Class: objects
    Properties:
      - Scalar = Union[int, float]
  Class: Domain
  Class: CartesianDomain
    Methods:
      - def __init__(self, **kwargs):
      - def discretize(self, n=None):
      - def states(self):
      - def min(self):
      - def max(self):
  Class: Conditional
    Properties:
      - signature = {"condition":
    Methods:
      - def __init__(self, condition, type, arguments):
  Class: Product
    Methods:
      - def __init__(self, *args: List):
      - def Matrix(*lines):
      - def Vector(*elements):
---


Path: /Volumes/Sync/GitHub/llorracc/dolo/dolo/compiler/recipes.py

---
Classes:
  Class: recipes
    Properties:
      - DATA_PATH = os.path.join(DIR_PATH, "recipes.yaml")
---


Path: /Volumes/Sync/GitHub/llorracc/dolo/dolo/misc/__init__.py

---

---


Path: /Volumes/Sync/GitHub/llorracc/dolo/dolo/misc/caching.py

---
Classes:
  Class: memoized
    Methods:
      - def __init__(self, func):
      - def __call__(self, *args, **kargs):
      - def __repr__(self):
      - def __get__(self, obj, objtype):
  Class: cachedondisk
    Methods:
      - def __init__(self, func):
      - def __call__(self, *args, **kargs):
      - def __repr__(self):
      - def __get__(self, obj, objtype):
      - def clear_cache(function_name=None):
  Class: DiskDictionary
    Methods:
      - def __init__(self, directory=".cache", funname="fun"):
      - def get_filename(self, key):
      - def __setitem__(self, key, value):
      - def get(self, item):
      - def hashable(obj):
---


Path: /Volumes/Sync/GitHub/llorracc/dolo/dolo/misc/decorators.py

---
Classes:
  Class: decorators
    Properties:
      - is_python_3 = sys.version_info >= (3, 0)
    Methods:
      - def deprecated(func):
      - def new_func(*args, **kwargs):
      - def test_deprecation():
---


Path: /Volumes/Sync/GitHub/llorracc/dolo/dolo/misc/display.py

---
Classes:
  Class: display
    Properties:
      - is_python_3 = sys.version_info >= (3, 0)
    Methods:
      - def read_file_or_url(url):
      - def pcat(filename, target="ipython"):
---


Path: /Volumes/Sync/GitHub/llorracc/dolo/dolo/misc/dprint.py

---
Classes:
  Class: bcolors
    Properties:
      - HEADER = "\033[95m"
      - OKBLUE = "\033[94m"
      - OKGREEN = "\033[92m"
      - WARNING = "\033[93m"
      - FAIL = "\033[91m"
      - ENDC = "\033[0m"
    Methods:
      - def disable(self):
      - def dprint(s):
---


Path: /Volumes/Sync/GitHub/llorracc/dolo/dolo/misc/graphs.py

---
Classes:
  Class: graphs
    Properties:
      - default_layout = {
 1:
    Methods:
      - def plot_irfs(
    sims,
    variables=None,
    titles=None,
    layout=None,
    horizon=None,
    figsize=None,
    plot_options={},
    line_options=None,
):
---


Path: /Volumes/Sync/GitHub/llorracc/dolo/dolo/misc/groot.py

---
Classes:
  Class: groot
    Methods:
      - def groot(path=""):
      - def check_filelist(l):
---


Path: /Volumes/Sync/GitHub/llorracc/dolo/dolo/misc/itprinter.py

---
Classes:
  Class: IterationsPrinter
    Methods:
      - def __init__(self, *knames, verbose=False):
      - def print_line(self):
      - def print_header(self, msg=None):
      - def print_iteration(self, **args):
      - def print_finished(self):
---


Path: /Volumes/Sync/GitHub/llorracc/dolo/dolo/misc/multimethod.py

---
Classes:
  Class: DispatchError
  Class: subtype
    Methods:
      - def __new__(cls, tp, *args):
      - def __init__(self, tp, *args):
      - def __getstate__(self):
      - def __eq__(self, other):
      - def __hash__(self):
      - def __subclasscheck__(self, subclass):
  Class: signature
    Properties:
      - parents = None  # type:
    Methods:
      - def __new__(cls, types: Iterable):
      - def __le__(self, other) -> bool:
      - def __lt__(self, other) -> bool:
      - def __sub__(self, other) -> tuple:
  Class: multimethod
    Properties:
      - pending = None  # type:
      - __version__ = "1.3"
    Methods:
      - def __new__(cls, func):
      - def __init__(self, func: Callable):
      - def register(self, *args):
      - def __get__(self, instance, owner):
      - def parents(self, types: tuple) -> set:
      - def clean(self):
      - def __setitem__(self, types: tuple, func: Callable):
      - def __delitem__(self, types: tuple):
      - def __missing__(self, types: tuple) -> Callable:
      - def __call__(self, *args, **kwargs):
      - def evaluate(self):
      - def docstring(self):
      - def groupby(func: Callable, values: Iterable) -> dict:
      - def get_types(func: Callable) -> tuple:
  Class: multidispatch
    Properties:
      - get_type = multimethod(type)
    Methods:
      - def get_type(arg: tuple):
      - def get_type(arg: Mapping):
      - def get_type(arg: Iterable):
      - def isa(*types) -> Callable:
  Class: overload
    Properties:
      - __get__ = multimethod.__get__
    Methods:
      - def __new__(cls, func):
      - def __init__(self, func: Callable):
      - def __call__(self, *args, **kwargs):
      - def register(self, func: Callable) -> Callable:
  Class: multimeta
  Class: __prepare__
    Methods:
      - def __init__(*args):
      - def __setitem__(self, key, value):
---


Path: /Volumes/Sync/GitHub/llorracc/dolo/dolo/misc/termcolor.py

---
Classes:
  Class: termcolor
    Properties:
      - __ALL__ = ["colored", "cprint"]
      - VERSION = (1, 1, 0)
      - ATTRIBUTES = dict(
 list( zip( ["bold", "dark", "", "underline", "blink", "", "reverse", "concealed"], list(range(1, 9)), ) )
      - HIGHLIGHTS = dict(
 list( zip( [ "on_grey", "on_red", "on_green", "on_yellow", "on_blue", "on_magenta", "on_cyan", "on_white", ], list(range(40, 48)), ) )
      - COLORS = dict(
 list( zip( [ "grey", "red", "green", "yellow", "blue", "magenta", "cyan", "white", ], list(range(30, 38)), ) )
      - RESET = "\033[0m"
    Methods:
      - def colored(text, color=None, on_color=None, attrs=None):
      - def cprint(text, color=None, on_color=None, attrs=None, **kwargs):
---


Path: /Volumes/Sync/GitHub/llorracc/dolo/dolo/misc/timing.py

---
Classes:
  Class: timing
    Methods:
      - def timeit(msg):
---


Path: /Volumes/Sync/GitHub/llorracc/dolo/dolo/numeric/discretization/__init__.py

---
Classes:
  Class: __init__
    Properties:
      - __author__ = "pablo"
---


Path: /Volumes/Sync/GitHub/llorracc/dolo/dolo/numeric/discretization/discretization.py

---
Classes:
  Class: discretization
    Methods:
      - def tauchen(N, mu, rho, sigma, m=2):
      - def rouwenhorst(rho, sigma, N):
      - def multidimensional_discretization(rho, sigma, N=3, method="rouwenhorst", m=2):
      - def tensor_markov(*args):
---


Path: /Volumes/Sync/GitHub/llorracc/dolo/dolo/numeric/discretization/quadrature.py

---
Classes:
  Class: quadrature
    Methods:
      - def hermgauss(n):
      - def gauss_hermite_nodes(orders, sigma, mu=None):
---


Path: /Volumes/Sync/GitHub/llorracc/dolo/dolo/numeric/extern/__init__.py

---

---


Path: /Volumes/Sync/GitHub/llorracc/dolo/dolo/numeric/extern/lmmcp.py

---
Classes:
  Class: lmmcp
    Properties:
      - eps1 = 1e-8  # default:
      - eps2 = 1e-12  # default:
      - null = 1e-8  # default:
      - Big = 1e10  # default:
      - kmax = 500  # default:
      - lambda1 = 0.1  # default:
      - lambda2 = 1 - lambda1
      - beta = 0.55  # default:
      - sigma = 1e-4  # default:
      - tmin = 1e-12  # default:
      - rho = 1e-8  # default:
      - p = 2.1  # default:
      - m = 10  # default:
      - kwatch = 20  # default:
      - watchdog = 1  # 1=watchdog strategy active, otherwise not
      - preprocess = True  # 1=preprocessor used, otherwise not
      - presteps = 20  # maximum number of preprocessing steps, default:
      - delta = 5  # default:
      - deltamin = 1  # default:
      - deltamax = 1e25  # default:
      - rho1 = 1e-4  # default:
      - rho2 = 0.75  # default:
      - sigma1 = 0.5  # default:
      - sigma2 = 2  # default:
      - eta = 0.95  # default:
      - defaults = dict(
 eps1=1e-10,  # default:
    Methods:
      - def lmmcp(fun, Dfun, x0, lb, ub, verbose=True, options={}):
      - def Phi3MCPPFB(x, Fx, lb, ub, lambda1, lambda2, n, Indexset):
      - def DPhi3MCPPFB(x, Fx, DFx, lb, ub, lambda1, lambda2, n, Indexset):
---


Path: /Volumes/Sync/GitHub/llorracc/dolo/dolo/numeric/extern/qz.py

---
Classes:
  Class: qz
    Methods:
      - def qzordered(A, B, crit=1.0):
      - def select(alpha, beta):
      - def test_qzordered():
---


Path: /Volumes/Sync/GitHub/llorracc/dolo/dolo/numeric/optimize/__init__.py

---
Classes:
  Class: __init__
    Properties:
      - __author__ = "pablo"
---


Path: /Volumes/Sync/GitHub/llorracc/dolo/dolo/numeric/optimize/ncpsolve.py

---
Classes:
  Class: ncpsolve
    Methods:
      - def ncpsolve(
    f, a, b, x, tol=1e-8, maxit=100, infos=False, verbose=False, jactype="serial"
):
      - def fcmp(z):
      - def smooth(x, a, b, fx, J, jactype="serial"):
---


Path: /Volumes/Sync/GitHub/llorracc/dolo/dolo/numeric/optimize/newton.py

---
Classes:
  Class: newton
    Properties:
      - old_print = print
      - serial_solve_numba = guvectorize("void(f8[:
      - serial_newton = newton
    Methods:
      - def solve(m, sol):
      - def serial_solve(A, B, diagnose=True):
      - def newton(f, x, verbose=False, tol=1e-6, maxit=5, jactype="serial"):
      - def SerialDifferentiableFunction(f, epsilon=1e-8):
      - def df(x):
      - def test_serial_solve():
---


Path: /Volumes/Sync/GitHub/llorracc/dolo/dolo/numeric/__init__.py

---

---


Path: /Volumes/Sync/GitHub/llorracc/dolo/dolo/numeric/decision_rule.py

---
Classes:
  Class: decision_rule
    Methods:
      - def filter_controls(a, b, ndims, controls):
  Class: Linear
  Class: Cubic
  Class: Chebychev
    Properties:
      - interp_methods = {
 "cubic":
  Class: CallableDecisionRule
    Methods:
      - def __call__(self, *args):
  Class: DecisionRule
    Properties:
      - exo_grid:
      - endo_grid:
      - namespace = dict()
      - multimethod = dispatch(namespace=namespace)
    Methods:
      - def __init__(
        self,
        exo_grid: Grid,
        endo_grid: Grid,
        interp_method="cubic",
        dprocess=None,
        values=None,
    ):
      - def set_values(self, x):
      - def eval_ms(self, m, s):
      - def eval_is(self, i, s):
      - def eval_s(self, s):
      - def eval_ijs(self, i, j, s):
      - def get_coefficients(
    itp: object,
    exo_grid: CartesianGrid,
    endo_grid: CartesianGrid,
    interp_type: Linear,
    x: object,
):
      - def eval_ms(
    itp: object,
    exo_grid: CartesianGrid,
    endo_grid: CartesianGrid,
    interp_type: Linear,
    m: object,
    s: object,
):
      - def eval_is(
    itp: object,
    exo_grid: CartesianGrid,
    endo_grid: CartesianGrid,
    interp_type: Linear,
    i: object,
    s: object,
):
      - def get_coefficients(
    itp: object,
    exo_grid: CartesianGrid,
    endo_grid: CartesianGrid,
    interp_type: Cubic,
    x: object,
):
      - def eval_ms(
    itp: object,
    exo_grid: CartesianGrid,
    endo_grid: CartesianGrid,
    interp_type: Cubic,
    m: object,
    s: object,
):
      - def eval_is(
    itp: object,
    exo_grid: CartesianGrid,
    endo_grid: CartesianGrid,
    interp_type: Cubic,
    i: object,
    s: object,
):
      - def get_coefficients(
    itp: object,
    exo_grid: UnstructuredGrid,
    endo_grid: CartesianGrid,
    interp_type: Linear,
    x: object,
):
      - def eval_is(
    itp: object,
    exo_grid: UnstructuredGrid,
    endo_grid: CartesianGrid,
    interp_type: Linear,
    i: object,
    s: object,
):
      - def get_coefficients(
    itp: object,
    exo_grid: UnstructuredGrid,
    endo_grid: CartesianGrid,
    interp_type: Cubic,
    x: object,
):
      - def eval_is(
    itp: object,
    exo_grid: UnstructuredGrid,
    endo_grid: CartesianGrid,
    interp_type: Cubic,
    i: object,
    s: object,
):
      - def get_coefficients(
    itp: object,
    exo_grid: UnstructuredGrid,
    endo_grid: CartesianGrid,
    interp_type: Linear,
    x: object,
):
      - def eval_is(
    itp: object,
    exo_grid: UnstructuredGrid,
    endo_grid: CartesianGrid,
    interp_type: Linear,
    i: object,
    s: object,
):
      - def get_coefficients(
    itp: object,
    exo_grid: EmptyGrid,
    endo_grid: CartesianGrid,
    interp_type: Linear,
    x: object,
):
      - def eval_s(
    itp: object,
    exo_grid: EmptyGrid,
    endo_grid: CartesianGrid,
    interp_type: Linear,
    s: object,
):
      - def get_coefficients(
    itp: object,
    exo_grid: EmptyGrid,
    endo_grid: CartesianGrid,
    interp_type: Cubic,
    x: object,
):
      - def eval_s(
    itp: object,
    exo_grid: EmptyGrid,
    endo_grid: CartesianGrid,
    interp_type: Cubic,
    s: object,
):
      - def eval_is(
    itp: object,
    exo_grid: EmptyGrid,
    endo_grid: object,
    interp_type: object,
    i: object,
    s: object,
):
      - def eval_ms(
    itp: object,
    exo_grid: EmptyGrid,
    endo_grid: object,
    interp_type: object,
    m: object,
    s: object,
):
  Class: ConstantDecisionRule
    Methods:
      - def __init__(self, x0):
      - def eval_s(self, s):
      - def eval_is(self, i, s):
      - def eval_ms(self, m, s):
  Class: CustomDR
    Methods:
      - def __init__(self, values, model=None):
      - def eval_ms(self, m, s):
---


Path: /Volumes/Sync/GitHub/llorracc/dolo/dolo/numeric/distribution.py

---
Classes:
  Class: distribution
    Properties:
      - Vector = List[float]
      - Matrix = List[Vector]
      - T = TypeVar("T")
  Class: Distribution
    Properties:
      - d:
      - names:
    Methods:
      - def draw(self, N: int) -> Matrix:
      - def integrate(self, f) -> float:
  Class: ContinuousDistribution
    Methods:
      - def discretize(self, **kwargs):
  Class: DiscreteDistribution
    Properties:
      - n:
      - origin:
    Methods:
      - def point(self, i) -> Vector:
      - def weight(self, i) -> float:
      - def items(self) -> Iterator[Tuple[float, Vector]]:
      - def integrate(self, fun: Callable[[Vector], T]) -> T:
  Class: EquiprobableDistribution
    Properties:
      - points:
    Methods:
      - def __init__(self, points: Vector = None, origin: Union[Distribution, None] = None):
      - def weights(self) -> Vector:
      - def point(self, i) -> float:
      - def weight(self, i) -> float:
      - def draw(self, N: int) -> Matrix:
      - def discretize(self, to="iid"):
      - def __repr__(self):
      - def __str__(self):
  Class: FiniteDistribution
    Properties:
      - points:
      - weights:
    Methods:
      - def __init__(
        self,
        points: Vector = None,
        weights: Vector = None,
        origin: Union[Distribution, None] = None,
    ):
      - def draw(self, N: int) -> Matrix:
      - def point(self, i) -> float:
      - def weight(self, i) -> float:
      - def discretize(self, to="iid"):
      - def __repr__(self):
      - def __str__(self):
      - def product_iid(iids: List[FiniteDistribution]) -> FiniteDistribution:
  Class: Bernouilli
    Properties:
      - π:
      - signature = {"π":
    Methods:
      - def __init__(self, π: float = None):
      - def discretize(self, to="iid"):
      - def draw(self, N: int) -> Matrix:
  Class: Binomial
    Properties:
      - π:
      - n:
  Class: UnivariateContinuousDistribution
    Properties:
      - d = 1
    Methods:
      - def ppf(self, quantiles: Vector) -> Vector:
      - def cdf(self, quantiles: Vector) -> Vector:
      - def discretize(self, to="iid", N=5, method="equiprobable", mass_point="median"):
      - def __discretize_ep__(self, N=5, mass_point="median"):
  Class: UNormal
    Properties:
      - μ:
      - σ:
      - signature = {"μ":
    Methods:
      - def __init__(self, σ: float = None, μ: float = None):
      - def ppf(self, quantiles):
      - def cdf(self, x):
      - def draw(self, N):
      - def integrate(self, fun) -> float:
      - def __discretize_gh__(self, N=5):
  Class: Uniform
    Properties:
      - a:
      - b:
      - signature = {"a":
    Methods:
      - def __init__(self, a: float = 0.0, b: float = 1.0):
      - def ppf(self, quantiles: Vector) -> Vector:
      - def cdf(self, x: Vector) -> Vector:
      - def draw(self, N) -> Matrix:
  Class: LogNormal
    Properties:
      - μ:
      - σ:
      - signature = {"μ":
    Methods:
      - def __init__(self, σ: float = 0.0, μ: float = 1.0):
      - def ppf(self, quantiles):
  Class: Beta
    Properties:
      - α:
      - β:
      - signature = {"α":
    Methods:
      - def __init__(self, α: float = None, β: float = None):
      - def ppf(self, quantiles):
  Class: Normal
    Properties:
      - Μ:
      - Σ:
      - signature = {"Σ":
      - MvNormal = Normal
    Methods:
      - def __init__(self, Σ=None, Μ=None):
      - def draw(self, N: int) -> Matrix:
      - def discretize(self, to="iid", N=None) -> FiniteDistribution:
      - def __repr__(self):
      - def __str__(self):
  Class: ProductDistribution
    Properties:
      - distributions:
      - C = TypeVar("C", bound=ContinuousDistribution)
      - C1 = TypeVar("C1", bound=ContinuousDistribution)
      - C2 = TypeVar("C2", bound=ContinuousDistribution)
    Methods:
      - def __init__(self, distributions: List[Distribution]):
      - def discretize(self, to="iid"):
      - def draw(self, N: int) -> Matrix:
      - def product_iid(iids: List[FiniteDistribution]) -> FiniteDistribution:
  Class: Truncation
    Properties:
      - dist:
    Methods:
      - def __init__(self, dist: C, lb=-np.inf, ub=np.inf):
      - def draw(self, N: int):
      - def ppf(self, quantiles: Vector) -> Vector:
  Class: Mixture
    Properties:
      - index:
      - distributions:
      - signature = {"index":
    Methods:
      - def __init__(self, index=None, distributions=None):
      - def discretize(self, to="iid"):
      - def draw(self, N: int) -> Matrix:
---


Path: /Volumes/Sync/GitHub/llorracc/dolo/dolo/numeric/filters.py

---
Classes:
  Class: filters
    Methods:
      - def hp_filter(data, lam=1600):
      - def bandpass_filter(data, k, w1, w2):
---


Path: /Volumes/Sync/GitHub/llorracc/dolo/dolo/numeric/grids.py

---
Classes:
  Class: grids
    Properties:
      - T = TypeVar("T")
      - S = TypeVar("S")
    Methods:
      - def prod(l):
  Class: Grid
    Methods:
      - def __mul__(self, rgrid):
      - def nodes(self):
      - def n_nodes(self):
      - def node(self, i):
  Class: ProductGrid
    Methods:
      - def __init__(self, g1: T, g2: S, names=None):
      - def __getitem__(self, v):
      - def __repr__(self):
  Class: EmptyGrid
    Properties:
      - type = "empty"
    Methods:
      - def nodes(self):
      - def n_nodes(self):
      - def node(self, i):
      - def __add__(self, g):
  Class: PointGrid
    Properties:
      - type = "point"
    Methods:
      - def __init__(self, point):
      - def nodes(self):
      - def n_nodes(self):
      - def node(self, i):
  Class: UnstructuredGrid
    Properties:
      - type = "unstructured"
    Methods:
      - def __init__(self, nodes):
  Class: CartesianGrid
  Class: UniformCartesianGrid
    Properties:
      - type = "UniformCartesian"
    Methods:
      - def __init__(self, min, max, n=[]):
      - def __add__(self, g):
      - def __numba_repr__(self):
  Class: NonUniformCartesianGrid
    Properties:
      - type = "NonUniformCartesian"
    Methods:
      - def __init__(self, list_of_nodes):
      - def __add__(self, g):
      - def __numba_repr__(self):
  Class: SmolyakGrid
    Properties:
      - type = "Smolyak"
    Methods:
      - def __init__(self, min, max, mu=2):
      - def cat_grids(grid_1, grid_2):
      - def node(grid, i):
      - def nodes(grid):
      - def n_nodes(grid):
---


Path: /Volumes/Sync/GitHub/llorracc/dolo/dolo/numeric/matrix_equations.py

---
Classes:
  Class: matrix_equations
    Properties:
      - TOL = 1e-10  # Tolerance for numerical convergence
    Methods:
      - def second_order_solver(FF, GG, HH, eigmax=1.0 + 1e-6):
      - def solve_sylvester_vectorized(*args):
      - def solve_sylvester(A, B, C, D, Ainv=None, method="linear"):
  Class: BKError
    Methods:
      - def __init__(self, type):
      - def __str__(self):
      - def solve_tensor(A, B):
---


Path: /Volumes/Sync/GitHub/llorracc/dolo/dolo/numeric/misc.py

---
Classes:
  Class: misc
    Methods:
      - def cartesian(arrays, out=None):
      - def mlinspace(a, b, orders, out=None):
      - def MyJacobian(fun, eps=1e-6):
      - def rfun(x):
---


Path: /Volumes/Sync/GitHub/llorracc/dolo/dolo/numeric/processes.py

---
Classes:
  Class: processes
    Properties:
      - Vector = List[float]
      - Matrix = List[Vector]
    Methods:
      - def choice(x, n, cumul):
      - def simulate_mc_indices(C, N, T, i0):
      - def simulate_markov_chain(nodes, transitions, N, T, i0=None, return_values=False):
  Class: Process
    Properties:
      - d:
      - variables:
    Methods:
      - def names(self):
      - def names(self, v):
  Class: DiscreteProcess
    Properties:
      - n:
  Class: ContinuousProcess
  Class: IIDProcess
    Methods:
      - def draw(self, n: int) -> Vector:
      - def response(self, T, impulse) -> DataArray:
      - def simulate(
        self, N: int = 10, T: int = 100, i0=None, m0=None, stochastic=True
    ) -> DataArray:
  Class: ConstantProcess
    Properties:
      - signature = {"μ":
    Methods:
      - def __init__(self, μ=None):
      - def discretize(self, to=None, **kwargs):
  Class: AggregateProcess
  Class: DiscretizedProcess
    Methods:
      - def iweight(self, i: int, j: int) -> float:
      - def inode(self, i: int, j: int) -> float:
      - def iteritems(self, i, eps=1e-16):
  Class: GDP
    Methods:
      - def __init__(self, nodes, inodes, iweights, grid=None):
      - def grid(self):
      - def n_nodes(self) -> int:
      - def node(self, i: int):
      - def nodes(self):
      - def n_inodes(self, i: int):
      - def inode(self, i, j):
      - def iweight(self, i, j):
  Class: DiscretizedIIDProcess
    Methods:
      - def point(self, i: int) -> int:
      - def weight(self, i: int) -> int:
      - def grid(self):
      - def n_nodes(self) -> int:
      - def node(self, i: int) -> Vector:
      - def n_inodes(self, i: int) -> int:
      - def inode(self, i: int, j: int):
      - def iweight(self, i: int, j: int):
  Class: MarkovChain
    Properties:
      - signature = {"transitions":
    Methods:
      - def __init__(self, transitions, values):
      - def discretize(self, to="mc"):
      - def grid(self):
      - def n_nodes(self):
      - def node(self, i: int):
      - def nodes(self):
      - def n_inodes(self, i: int):
      - def inode(self, i: int, j: int):
      - def iweight(self, i: int, j: int):
      - def simulate(self, N, T, i0=0, m0=None, stochastic=True):
  Class: ProductProcess
    Methods:
      - def __init__(self, *l):
      - def discretize(self, to=None, options={}):
      - def simulate(self, N, T, m0=None, stochastic=True):
      - def Product(*processes):
      - def product_mc(markov_chains: List[MarkovChain]) -> MarkovChain:
      - def product_gdp(gdps: List[GDP]) -> GDP:
  Class: AR1
    Properties:
      - signature = {"ρ":
    Methods:
      - def __init__(self, ρ=None, σ=None, μ=None):
      - def discretize(self, N=3, to="mc", **kwargs):
      - def discretize_mc(self, N=3):
      - def discretize_gdp(self, N=3):
      - def simulate(self, N, T, m0=None, stochastic=True):
      - def response(self, T, impulse):
  Class: VAR1
    Properties:
      - signature = {"ρ":
    Methods:
      - def __init__(self, ρ=None, Σ=None, μ=None):
      - def discretize(self, N=3, to="mc", **kwargs):
      - def discretize_mc(self, N=3):
      - def discretize_gdp(self, N=3):
      - def simulate(self, N, T, m0=None, stochastic=True):
      - def response(self, T, impulse):
  Class: Conditional
    Properties:
      - signature = {"condition":
    Methods:
      - def __init__(self, condition=None, type=None, arguments=None):
---


Path: /Volumes/Sync/GitHub/llorracc/dolo/dolo/numeric/serial_operations.py

---
Classes:
  Class: serial_operations
    Properties:
      - serial_solve_numba = guvectorize(
 "void(f8[:
    Methods:
      - def numdiff1(f, x0, dv=1e-8):
      - def numdiff2(f, x0, dv=1e-8):
      - def solve(m, sol):
      - def serial_solve(A, B, diagnose=True):
      - def serial_multiplication(A, B):
---


Path: /Volumes/Sync/GitHub/llorracc/dolo/dolo/numeric/taylor_expansion.py

---
Classes:
  Class: TaylorExpansion
    Methods:
      - def __init__(self, *l):
      - def __getitem__(self, ind):
      - def eval_s(self, points):
      - def eval_ms(self, m, s):
      - def eval_te_order_1(s0, x0, x1, points, out):
      - def eval_te_order_2(s0, x0, x1, x2, points, out):
      - def eval_te_order_3(s0, x0, x1, x2, x3, points, out):
  Class: CDR
    Methods:
      - def test_taylor_expansion():
---


Path: /Volumes/Sync/GitHub/llorracc/dolo/dolo/numeric/tensor.py

---
Classes:
  Class: tensor
    Methods:
      - def multidot_old(ten, mats):
      - def mdot_signature(M, *C):
      - def mdot(M, *C):
      - def sdot(U, V):
      - def multitake(a, inds, axes):
---


Path: /Volumes/Sync/GitHub/llorracc/dolo/dolo/tests/__init__.py

---

---


Path: /Volumes/Sync/GitHub/llorracc/dolo/dolo/tests/test_caching.py

---
Classes:
  Class: Counter
    Properties:
      - n = 0
    Methods:
      - def fun(a, b):
  Class: CachingTestCase
    Methods:
      - def test_cacheondisk(self):
      - def test_cache_arrays(self):
---


Path: /Volumes/Sync/GitHub/llorracc/dolo/dolo/tests/test_complementarity_problems.py

---
Classes:
  Class: test_complementarity_problems
    Methods:
      - def josephy(x):
      - def Djosephy(x):
  Class: ComplementaritySolve
    Methods:
      - def test_lmmcp(self):
---


Path: /Volumes/Sync/GitHub/llorracc/dolo/dolo/tests/test_customdr.py

---
Classes:
  Class: test_customdr
    Methods:
      - def test_custom_dr():
      - def finite_time_iteration():
---


Path: /Volumes/Sync/GitHub/llorracc/dolo/dolo/tests/test_egm.py

---
Classes:
  Class: test_egm
    Methods:
      - def test_egm_iid():
---


Path: /Volumes/Sync/GitHub/llorracc/dolo/dolo/tests/test_ergodic.py

---
Classes:
  Class: test_ergodic
    Methods:
      - def test_ergo_iid():
      - def test_ergo_mc():
---


Path: /Volumes/Sync/GitHub/llorracc/dolo/dolo/tests/test_formula_evaluation.py

---
Classes:
  Class: test_formula_evaluation
    Methods:
      - def test_eval_formula():
---


Path: /Volumes/Sync/GitHub/llorracc/dolo/dolo/tests/test_grid.py

---
Classes:
  Class: test_grid
    Methods:
      - def test_grids():
---


Path: /Volumes/Sync/GitHub/llorracc/dolo/dolo/tests/test_grids.py

---
Classes:
  Class: test_grids
    Methods:
      - def test_grids():
---


Path: /Volumes/Sync/GitHub/llorracc/dolo/dolo/tests/test_iid_processes.py

---
Classes:
  Class: test_iid_processes
    Methods:
      - def f(x):
      - def test_Mixture():
      - def test_UNormal():
      - def test_Uniform():
      - def test_Lognormal():
      - def test_beta():
---


Path: /Volumes/Sync/GitHub/llorracc/dolo/dolo/tests/test_import.py

---
Classes:
  Class: test_import
    Methods:
      - def test_import():
      - def test_old_models():
---


Path: /Volumes/Sync/GitHub/llorracc/dolo/dolo/tests/test_irf.py

---
Classes:
  Class: test_irf
    Methods:
      - def test_irf():
---


Path: /Volumes/Sync/GitHub/llorracc/dolo/dolo/tests/test_linter.py

---

---


Path: /Volumes/Sync/GitHub/llorracc/dolo/dolo/tests/test_model_import.py

---
Classes:
  Class: test_model_import
    Methods:
      - def model_evaluation(compiler="numpy", data_layout="columns"):
---


Path: /Volumes/Sync/GitHub/llorracc/dolo/dolo/tests/test_serial_ncpsolve.py

---
Classes:
  Class: test_serial_ncpsolve
    Methods:
      - def josephy(x):
      - def Djosephy(x):
  Class: SerialSolve
    Methods:
      - def test_serial_solve(self):
      - def serial_fun(xvec):
      - def serial_fun(xvec):
---


Path: /Volumes/Sync/GitHub/llorracc/dolo/dolo/__init__.py

---

---


Path: /Volumes/Sync/GitHub/llorracc/dolo/dolo/config.py

---
Classes:
  Class: config
    Properties:
      - save_plots = False
      - real_type = "double"
      - debug = False
      - temp_dir = tempfile.mkdtemp(prefix="dolo_")
    Methods:
      - def warning_on_one_line(message, category, filename, lineno, file=None, line=None):
---


Path: /Volumes/Sync/GitHub/llorracc/dolo/dolo/linter.py

---

---


Path: /Volumes/Sync/GitHub/llorracc/dolo/experiments/python_self_contained.py

---
Classes:
  Class: python_self_contained
    Properties:
      - Vector = List[float]
  Class: PureModel
    Properties:
      - symbols:
      - calibration:
      - functions:
      - domain:
      - exogenous:
      - symbols = dict(
 states=["z", "k"], controls=["n", "i"], exogenous=["e_z"], parameters=["β", "δ", "α", "ρ", "σ", "η", "χ"],
      - calibration_strings = dict(
 # parameters, β="0.99", δ="0.025", α="0.33", ρ="0.8", σ="5", η="1", zbar="0", χ="w/c**σ/n**η", c_i="1.5", c_y="0.5", e_z="0.0", # = "endogenous variables", n="0.33", z="zbar", rk="1/β-1+δ", w="(1-α)*exp(z)*(k/n)**(α)", k="n/(rk/α)**(1/(1-α))", y="exp(z)*k**α*n**(1-α)", i="δ*k", c="y - i", V="log(c)/(1-β)", u="c**(1-σ)/(1-σ) - χ*n**(1+η)/(1+η)", m="β/c**σ*(1-δ+rk)",
      - calibration_dict = solve_triangular_system(calibration_strings)
      - calibration_vector = calibration_to_vector(symbols, calibration_dict)
      - calibration = CalibrationDict(symbols, calibration_vector)
      - transition = standard_function(transition_gu, 2)
      - arbitrage = standard_function(arbitrage_gu, 2)
      - functions = {"transition":
      - exogenous = UNormal(σ=0.001)
      - domain = CartesianDomain(z=[-0.01, 0.01], k=[5, 15])
      - model = PureModel(symbols, calibration, functions, domain, exogenous)
      - dr0 = perturb(model)
    Methods:
      - def discretize(self, **kwargs) -> Tuple[Grid, DiscretizedProcess]:
      - def transition_(m, s, x, M, p):
      - def arbitrage_(m, s, x, M, S, X, p):
      - def transition_gu(m, s, x, M, p, out):
      - def arbitrage_gu(m, s, x, M, S, X, p, out):
---

</Complete Definitions>
</file_map>

